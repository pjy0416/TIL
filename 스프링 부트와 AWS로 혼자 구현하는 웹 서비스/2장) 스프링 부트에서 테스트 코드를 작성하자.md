<h3>테스트 코드 소개</h3>

- TDD vs 단위 테스트

  - TDD - 테스트가 주도하는 개발 (테스트 코드를 먼저 작성하는 것부터 시작)
  - 레드 그린 사이클
    - 항상 실패하는 테스트를 먼저 작성하고(Red)
    - 테스트가 통과하는 프로덕션 코드를 작성하고(Green)
    - 테스트가 통과하면 프로덕션 코드를 리팩토링함(Refactor)
  - 단위 테스트 - TDD의 첫 번째 단계인 기능 단위의 테스트 코드를 작성하는 것
    - 따라서, 테스트 코드를 먼저 작성하지 않아도, 리팩토링을 포함하지 않아도 됨
    - 개발 단계 초기에 문제를 발견하게 도와준다.
    - 리팩토링을 하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확인할 수 있음
    - 기능에 대한 불확실성을 감소
    - 시스템에 대한 실제 문서를 제공
  - 단위 테스트 장점
    - 빠른 피드백
    - **자동검증**이 가능
    - **개발자가 만든 기능을 안전하게 보호 ~> 새로운 기능이 추가될 때, 기존 기능이 잘 작동되는 것을 보장**
  - xUnit - 테스트 프레임워크
    - x(개발 환경)에 따라 Unit 테스트를 도와주는 도구
    - Java - JUnit, DB - DBUnit ...
      

- Hello Controller 테스트 코드 작성하기

  - 일반적으로 패키지 명은 웹 사이트 주소의 역순으로 만듬

    - ex)admin.zin0.com 사이트 -> com.zin0.admin 패키지명

  - 앞으로 만들 프로젝트의 메인 클래스가 될 Application 클래스를 만든다.

    ```java
    package com.zin0.book.springboot;
    
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    
    @SpringBootApplication
    public class Application {
        public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
        }
    }
    ```

  - @SpringBootApplication - 스프링 부트의 자동 설정, 스프링 Bean 읽기와 생성을 모두 자동으로 설정

  - <u>**@SpringBootApplication이 있는 위치부터 설정을 읽어 나가기 때문에, 이 클래스는 항상 프로젝트의 최상단에 위치**</u>해야만 한다.

  - main 메소드의 SpringApplication.run으로 인해 내장 WAS를 실행

  - 내장 WAS - **언제 어디서나 같은 환경에서 스프링 부트를 배포**할 수 있음
    

  - 컨트롤러와 관련된 것을 담을 패키지(여기서는 web)을 만든다.

  - HelloController 클래스를 만든다.

    ```java
    package com.zin0.book.springboot.web;
    
    import com.zin0.book.springboot.web.dto.HelloResponseDto;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    
    @RestController
    public class HelloController {
        @GetMapping("/hello")
        public String Hello() {
            return "hello";
        }
    }
    ```

  - @RestController

    - 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어 준다.
    - @ResponseBody를 각 메소드마다 선언했던 것을 한번에 사용할 수 있게 해준다고 생각하면 편함

  - @GetMapping

    - Get 요청을 받을 수 있는 API를 만든다.
      

  - 테스트 코드 검증을 위해, test에 HelloControllerTest 클래스를 생성한다.

    - **검증할 것과 패키지 이름이 같아야함**(실습하다가 에러를 반환하길래 패키지명에 오타가 있어서 바꿔줬더니 됐음)

    - 보통 클래스 이름은 검증할 클래스 이름에 Test를 붙임

      ```java
      package com.zin0.book.springboot;
      
      import com.zin0.book.springboot.web.HelloController;
      import org.junit.Test;
      import org.junit.runner.RunWith;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
      import org.springframework.test.context.junit4.SpringRunner;
      import org.springframework.test.web.servlet.MockMvc;
      
      import static org.hamcrest.Matchers.is;
      import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
      import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
      
      @RunWith(SpringRunner.class)
      @WebMvcTest(controllers = HelloController.class)
      public class HelloControllerTest {
          @Autowired
          private MockMvc mvc;
      
          @Test
          public void hello가_리턴된다() throws Exception {
              String hello = "hello";
      
              mvc.perform(get("/hello"))
                      .andExpect(status().isOk())
                      .andExpect(content().string(hello));
          }
      }
      ```

  - @RunWith(SpringRunner.class)

    - 테스트 진행 시, **JUnit에 내장된 실행자 외에 다른 실행자를 실행**시킴
    - 여기서는 SpringRunner라는 스프링 실행자를 사용
    - 즉, 스프링 부트 테스트와 JUnit 사이에 연결자 역할

  - @WebMvcTest
    - 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션
    - 선언할 경우 @Controller, @ControllerAdvice 등을 사용 가능
    - 단, @Service, @Component, @Repository 등 사용 불가
    - 위의 클래스는 Controller 클래스기 때문에 선언함
  - @Autowired
    - 스프링이 관리하는 빈(Bean)을 주입 받음
  - @private MockMvc mvc
    - 웹 API를 테스트할 때 사용 (Get, Post 등)
    - **스프링 MVC 테스트의 시작점**
  - mvc.perform(get("hello"))
    - MockMvc를 통해 /hello 주소로 GET 요청을 보냄
    - 체이닝이 지원 ~> 따라서 여러 검증 기능을 이어서 선언 가능
  - .andExpect(status().isOk())
    - mvc.perform의 결과를 검증
    - HTTP Header의 Status를 검증 ( 200, 404, 500 등 상태)
    - 여기선 200인지 아닌지 검증
  - .andExpect(content().string(hello))
    - mvc.perform의 결과 검증 ~> 응답 본문의 내용을 검증
    - Controller에서 "hello"를 리턴하기 때문에 이 값이 맞는지 검증
      

---

- 롬복 소개 및 설치

  - 롬복 - **자바 개발자들의 필수 라이브러리**
    - Getter, Setter, 기본 생성자, toString 등을 어노테이션으로 자동 생성해준다.
    - <u>**build.gradle의 의존성 부분에 compile('org.projectlombok:lombok')을 추가**</u>
    - [ Ctrl + Shift + A ]를 통해 Plugins를 선택해주고 Marketplace에서 롬복 플러그인을 인스톨해준다. (인스톨 후 재시작 필수) ~> 알림창 Enable 클릭 or "Setting -> Build -> Compiler -> Annotation Processors"에서 Enable 설정

- Hello Controller 코드를 롬복으로 전환하기

  - 테스트 코드가 작성한 코드를 지켜주기 때문에, 쉽게 변경할 수 있다.

  - web 패키지에 모든 응답 Dto를 담을 dto 패키지를 추가

  - HelloResponseDto 클래스를 생성

    ```java
    package com.zin0.book.springboot.web.dto;
    
    import lombok.Getter;
    import lombok.RequiredArgsConstructor;
    
    @Getter
    @RequiredArgsConstructor
    public class HelloResponseDto {
        private final String name;
        private final int amount;
    }
    ```

  - @Getter 

    - 선언된 모든 필드의 get 메소드를 생성

  - @RequiredArgsConstructor

    - 선언된 모든 final 필드가 포함된 생성자를 생성
    - <u>**final이 없는 필드는 생성자에 포함 X**</u>

  - HelloResponseDtoTest 클래스 생성

    ```java
    package com.zin0.book.springboot.dto;
    
    import com.zin0.book.springboot.web.dto.HelloResponseDto;
    import org.junit.Test;
    
    import static org.assertj.core.api.Assertions.assertThat;
    
    public class HelloResponseDtoTest {
        @Test
        public void 롬복_기능_테스트() {
            //given
            String name = "test";
            int amount = 1000;
    
            //when
            HelloResponseDto dto = new HelloResponseDto(name, amount);
    
            //then
            assertThat(dto.getName()).isEqualTo(name);
            assertThat(dto.getAmount()).isEqualTo(amount);
        }
    }
    ```

  - aseertThat

    - assertj라는 테스트 검증 라이브러리의 검증 메소드
    - 검증하고 싶은 대상을 메소드 인자로 받음
    - 메소드 체이닝 지원

  - Junit의 기본 assertThat이 아닌 assertj의 assertThat을 사용한 이유

    - Junit의 assertThat을 쓰게 되면, is()와 같이 CoreMatchers 라이브러리가 필요하다.
    - 하지만, Junit은 추가적 라이브러리가 필요 X
    - assertj는 Junit에서 자동으로 라이브러리 등록을 해줌
      

  - HelloController에 ResponseDto 사용하도록 추가

    ```java
    package com.zin0.book.springboot.web;
    
    import com.zin0.book.springboot.web.dto.HelloResponseDto;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    
    @RestController
    public class HelloController {
        @GetMapping("/hello")
        public String Hello() {
            return "hello";
        }
    
        @GetMapping("/hello/dto")
        public HelloResponseDto helloDto(@RequestParam("name") String name, @RequestParam("amount") int amount) {
            return new HelloResponseDto(name, amount);
        }
    }
    ```

  - @RequestParam

    - 외부에서 API로 넘긴 파라미터를 가져오는 어노테이션
      

  - HelloControllerTest에 테스트 코드 작성

    ```
    package com.zin0.book.springboot;
    
    import com.zin0.book.springboot.web.HelloController;
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
    import org.springframework.test.context.junit4.SpringRunner;
    import org.springframework.test.web.servlet.MockMvc;
    
    import static org.hamcrest.Matchers.is;
    import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
    
    @RunWith(SpringRunner.class)
    @WebMvcTest(controllers = HelloController.class)
    public class HelloControllerTest {
        @Autowired
        private MockMvc mvc;
    
        @Test
        public void hello가_리턴된다() throws Exception {
            String hello = "hello";
    
            mvc.perform(get("/hello"))
                    .andExpect(status().isOk())
                    .andExpect(content().string(hello));
        }
    
        @Test
        public void HelloDto가_리턴된다() throws Exception {
            String name = "hello";
            int amount = 1000;
    
            mvc.perform(get("/hello/dto")
                                            .param("name", name)
                                            .param("amount",String.valueOf(amount)))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.name",is(name)))
                    .andExpect(jsonPath("$.amount", is(amount)));
        }
    }
    ```

  - param

    - API 테스트할 때 사용될 요청 파라미터를 설정
    - **값은 String만 허용 (숫자/날짜 등 데이터도 문자열로 변경해주어야함)**

  - jsonPath

    - JSON 응답값을 필드별로 검증
    - $를 기준으로 필드명 명시 해줘야함
      

---

<h5>추가)</h5>

main의 Application 클래스를 직접 확인하는 과정에서, Error를 반환

(8080포트가 이미 점유되었다고 반환)



1. cmd를 통해서 port를 죽이려고 시도했지만 실패했다.
2. /f를 써서 강제로 지우려고 했지만, 어떤 프로세스의 자식 프로세스라서 종료할 수 없다고 나왔다.

3. 그래서, 연결 포트를 바꿔주기로 결정했다.

   -> resources에 있는 applications.properties에 

   server.port = 원하는 포트번호

   를 추가해서 연결 포트를 바꿔주었다.

   (applications.properties가 없어서 만들어줬음)