import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class test_14430 {
//	 (1,1) ~ (300,300) 의 좌표가 존재
//	 탐사로봇은 한번의 턴에 아래 or 오른쪽 한번만 이동 가능
//	 첫째 줄에 WOOK이 탐사할 영역의 세로길이 N(1≤N≤300)과 가로길이 M(1≤M≤300)이 주어진다.
//	 그 다음 N행 M열에 걸쳐 탐사영역에 대한 정보가 주어진다. 숫자는 공백으로 구분된다. (자원은 1, 빈 땅은 0으로 표시된다)
//	 최대한 광석을 캘 수 있는 개수를 출력하라
/*	private static int[] checkYLine(int[][] res, int yMax, int xMax) {
		int[] tmpY = new int[yMax];
		
		for(int x=0; x<xMax; x++) {
			for(int y=0; y<yMax; y++) {
				if(res[y][x] == 1) {
					tmpY[x]++;
				}
			}
		}
		
		return tmpY;
	}
	
	private static int findMax(int[][] resourse, int[] xLine, int[] yLine, int xMax, int yMax) {
		// xLine과 yLine를 정렬해서 최대값을 찾아냄 
		// 쭉 돌면서 최대값과 같은 라인의 인덱스를 저장
		// x,y 저장된 인덱스를 기준으로 x or y의 최대와 같은 라인을 찾음
		int[] tmpX = xLine.clone();	// copy array
		int[] tmpY = yLine.clone(); // copy array
		ArrayList<Integer> xIdx = new ArrayList<Integer>();
		ArrayList<Integer> yIdx = new ArrayList<Integer>();
		
		Arrays.sort(tmpX);	//최대값 search를 위한 sorting
		Arrays.sort(tmpY);	
		
		for(int i=0; i<xMax; i++) {
			if(xLine[i] == tmpX[xMax-1]) {
				xIdx.add(i);
			}
		}
		
		for(int i=0; i<yMax; i++) {
			if(yLine[i] == tmpY[yMax-1]) {
				yIdx.add(i);
			}
		}
		
		
		int xSize = xIdx.size();
		int ySize = yIdx.size();
		
		int firstX = xIdx.get(0);
		int firstY = yIdx.get(0);
		int lastX = xIdx.get(xSize-1);
		int lastY = yIdx.get(ySize-1);
		
		for(int y=firstY; y<lastY; y++) {
			for(int x=firstX; x<lastX; x++) {
				
			}
		}
		
		return 0;
	}*/
	
	public static void main(String[] args) {
		int[] robot = {1,1};
		
		Scanner scan = new Scanner(System.in);
		 
		int yMax = scan.nextInt();
		int xMax = scan.nextInt();
		
		scan.nextLine();		// 개행열 제거
		
		int[][] resourses = new int[yMax][xMax];
		int[][] count = new int[yMax+1][xMax+1]; 
				
		for(int y=0; y<yMax; y++) {
			for(int x=0; x<xMax; x++) {
				resourses[y][x] = scan.nextInt();
			}
		}
		
		for(int y=0; y<yMax; y++) {
			int tmpY = y+1;
			for(int x=0; x<xMax; x++) {
				int tmpX = x+1;
				count[tmpY][tmpX] = resourses[y][x] + Math.max(count[tmpY][tmpX-1], count[tmpY-1][tmpx]);
			}
		}
		
		//////////////////////////////////////////////////////////////
		
		/*int[] yLine = new int[xMax];	// xResourse in yLine
		int[] xLine = new int[yMax];	// yResourse in xLine
		
		for(int y=0; y<yMax; y++) {
			for(int x=0; x<xMax; x++) {
				int tmp = scan.nextInt();
				if(tmp ==1) {
					xLine[y]++;
				}
				resourses[y][x] = tmp;
			}
		}
		
		yLine = checkYLine(resourses, yMax, xMax);*/
	}
}
