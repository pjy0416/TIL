import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class test_14430 {
//	 (1,1) ~ (300,300) 의 좌표가 존재
//	 탐사로봇은 한번의 턴에 아래 or 오른쪽 한번만 이동 가능
//	 첫째 줄에 WOOK이 탐사할 영역의 세로길이 N(1≤N≤300)과 가로길이 M(1≤M≤300)이 주어진다.
//	 그 다음 N행 M열에 걸쳐 탐사영역에 대한 정보가 주어진다. 숫자는 공백으로 구분된다. (자원은 1, 빈 땅은 0으로 표시된다)
//	 최대한 광석을 캘 수 있는 개수를 출력하라
/*	private static int[] checkYLine(int[][] res, int yMax, int xMax) {
		int[] tmpY = new int[yMax];
		
		for(int x=0; x<xMax; x++) {
			for(int y=0; y<yMax; y++) {
				if(res[y][x] == 1) {
					tmpY[x]++;
				}
			}
		}
		
		return tmpY;
	}
	
	private static int findMax(int[][] resourse, int[] xLine, int[] yLine, int xMax, int yMax) {
		// xLine과 yLine를 정렬해서 최대값을 찾아냄 
		// 쭉 돌면서 최대값과 같은 라인의 인덱스를 저장
		// x,y 저장된 인덱스를 기준으로 x or y의 최대와 같은 라인을 찾음
		int[] tmpX = xLine.clone();	// copy array
		int[] tmpY = yLine.clone(); // copy array
		ArrayList<Integer> xIdx = new ArrayList<Integer>();
		ArrayList<Integer> yIdx = new ArrayList<Integer>();
		
		Arrays.sort(tmpX);	//최대값 search를 위한 sorting
		Arrays.sort(tmpY);	
		
		for(int i=0; i<xMax; i++) {
			if(xLine[i] == tmpX[xMax-1]) {
				xIdx.add(i);
			}
		}
		
		for(int i=0; i<yMax; i++) {
			if(yLine[i] == tmpY[yMax-1]) {
				yIdx.add(i);
			}
		}
		
		
		int xSize = xIdx.size();
		int ySize = yIdx.size();
		
		int firstX = xIdx.get(0);
		int firstY = yIdx.get(0);
		int lastX = xIdx.get(xSize-1);
		int lastY = yIdx.get(ySize-1);
		
		for(int y=firstY; y<lastY; y++) {
			for(int x=firstX; x<lastX; x++) {
				
			}
		}
		
		return 0;
	}*/
	
	public static void main(String[] args) {
		int[] robot = {1,1};
		
		Scanner scan = new Scanner(System.in);
		 
		int yMax = scan.nextInt();
		int xMax = scan.nextInt();
		
		scan.nextLine();		// 개행열 제거
		
		int[][] resourses = new int[yMax][xMax];
				
		for(int y=0; y<yMax; y++) {
			for(int x=0; x<xMax; x++) {
				resourses[y][x] = scan.nextInt();
			}
		}
		int count =0;
		if(resourses[0][0] ==1) {
			count++;
		}
		boolean back = false;
		boolean moveY = false;
		boolean moveX = false;
		for(int y=0, x=0; y<yMax-1 || x<xMax-1;) {
			System.out.println("x :"+x +" y :"+y);
			if(x+1 >= xMax) {
				for(int i=y; y<yMax; y++) {
					if(resourses[i][x] ==1) {
						count++;
					}
				}
				break;
			}
			if(y+1 >= yMax) {
				for(int i=x; x<xMax; x++) {
					if(resourses[y][i] ==1) {
						count++;
					}
				}
				break;
			}
			int big = Math.max(resourses[y+1][x], resourses[y][x+1]);
			if(back) {
				if(moveY) {
					x++;
					back =false;
					moveY=false;
					moveX=true;
				}else {
					y++;
					back =false;
					moveX=false;
					moveY=true;
				}
				continue;
			}
			
			if(big ==0) {
				back =true;
				count--;
				if(moveY) {
					y--;
				}else if(moveX) {
					x--;
				}else {
					break;
				}
				continue;
			}
			if(resourses[y+1][x] ==big) {
				y++;
				moveY =true;
			}else {
				x++;
				moveX = true;
			}
			count++;
		}
		
		System.out.println(count);
		
		//////////////////////////////////////////////////////////////
		
		/*int[] yLine = new int[xMax];	// xResourse in yLine
		int[] xLine = new int[yMax];	// yResourse in xLine
		
		for(int y=0; y<yMax; y++) {
			for(int x=0; x<xMax; x++) {
				int tmp = scan.nextInt();
				if(tmp ==1) {
					xLine[y]++;
				}
				resourses[y][x] = tmp;
			}
		}
		
		yLine = checkYLine(resourses, yMax, xMax);*/
	}
}
